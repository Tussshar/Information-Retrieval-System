/*
 * To change this license header, choose License Headers in Project Properties.
 * To change this template file, choose Tools | Templates
 * and open the template in the editor.
 */
package com.neu.irs.userInterface;

import com.neu.irs.bean.Doc;
import com.neu.irs.bean.Document;
import com.neu.irs.bean.DocumentCatalog;
import com.neu.irs.commonUtil.Porter;
import com.neu.irs.commonUtil.RankingFunction;
import com.neu.irs.dataStructure.Graph;
import com.neu.irs.dataStructure.Graph.Node;
import com.neu.irs.dataStructure.Index;
import com.neu.irs.dataStructure.InvertedIndex;
import java.io.BufferedReader;
import java.io.File;
import java.io.FileReader;
import java.util.ArrayList;
import java.util.Collection;
import java.util.Collections;
import java.util.HashMap;
import java.util.HashSet;
import java.util.Set;
import javax.swing.JFrame;
import javax.swing.JPanel;

/**
 *
 * @author tusharkale1
 */
public class AdminJPanel extends javax.swing.JPanel {

    /**
     * Creates new form AdminJPanel
     */
    private JFrame mainJFrame;
    private JPanel userProcessContainer;

    private ArrayList<File> selectedFiles;
    private ArrayList<Document> documentList;
    private InvertedIndex indexTable;
    private ArrayList<Doc> docList;
    private Index newIndex;
    private ArrayList<String> stopList;
    private DocumentCatalog docCatalog;
    Set<Integer> docSet = new HashSet<Integer>();
    public AdminJPanel(JPanel userProcessContainer, JFrame mainJFrame, ArrayList<File> selectedFiles, ArrayList<Document> documentList, InvertedIndex indexTable, ArrayList<Doc> docList, Index newIndex, DocumentCatalog docCatalog) {
        initComponents();

        this.userProcessContainer = userProcessContainer;
        this.mainJFrame = mainJFrame;

        this.selectedFiles = selectedFiles;
        this.documentList = documentList;
        this.indexTable = indexTable;
        this.docList = docList;
        this.newIndex = newIndex;
        this.docCatalog = docCatalog;
        stopList = new ArrayList<>();
        storeStopList();
    }

    private void storeStopList() {
        File stopFile = new File("/Users/tusharkale1/Desktop/Tushar/IRS/stopfile");

        Porter porter = new Porter();
        try {
            StringBuffer contentBuffer = null;
            BufferedReader bufferedReader = new BufferedReader(new FileReader(stopFile));
            contentBuffer = new StringBuffer();

            String line = bufferedReader.readLine();
            while (line != null) {
                contentBuffer.append(line).append(" ");
                line = bufferedReader.readLine();
            }

            String[] words = contentBuffer.toString().split(" ");

            for (int i = 0; i < words.length; i++) {
                String stopWord = porter.stripAffixes(words[i]);
                stopList.add(stopWord);
            }
            int size = stopList.size();

        } catch (Exception e) {
            e.printStackTrace();
        }
    }

    /**
     * This method is called from within the constructor to initialize the form.
     * WARNING: Do NOT modify this code. The content of this method is always
     * regenerated by the Form Editor.
     */
    @SuppressWarnings("unchecked")
    // <editor-fold defaultstate="collapsed" desc="Generated Code">//GEN-BEGIN:initComponents
    private void initComponents() {

        txtSearch = new javax.swing.JTextField();
        btnSearch = new javax.swing.JButton();
        btnParseNewData = new javax.swing.JButton();
        lblWelcome = new javax.swing.JLabel();
        jLabel1 = new javax.swing.JLabel();

        btnSearch.setFont(new java.awt.Font("Phosphate", 1, 12)); // NOI18N
        btnSearch.setText("Search");
        btnSearch.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                btnSearchActionPerformed(evt);
            }
        });

        btnParseNewData.setFont(new java.awt.Font("Phosphate", 1, 12)); // NOI18N
        btnParseNewData.setText("Parse New Data");
        btnParseNewData.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                btnParseNewDataActionPerformed(evt);
            }
        });

        lblWelcome.setFont(new java.awt.Font("Tahoma", 1, 18)); // NOI18N
        lblWelcome.setForeground(new java.awt.Color(102, 204, 255));
        lblWelcome.setText("Welcome to Information Retrieval System");
        lblWelcome.setBorder(javax.swing.BorderFactory.createMatteBorder(3, 3, 3, 3, new java.awt.Color(204, 0, 0)));

        jLabel1.setFont(new java.awt.Font("Tahoma", 1, 18)); // NOI18N
        jLabel1.setIcon(new javax.swing.ImageIcon(getClass().getResource("/com/neu/irs/image/search.jpg"))); // NOI18N

        javax.swing.GroupLayout layout = new javax.swing.GroupLayout(this);
        this.setLayout(layout);
        layout.setHorizontalGroup(
            layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGroup(layout.createSequentialGroup()
                .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
                    .addGroup(layout.createSequentialGroup()
                        .addGap(500, 500, 500)
                        .addComponent(jLabel1))
                    .addGroup(layout.createSequentialGroup()
                        .addGap(470, 470, 470)
                        .addComponent(lblWelcome, javax.swing.GroupLayout.PREFERRED_SIZE, 391, javax.swing.GroupLayout.PREFERRED_SIZE))
                    .addGroup(layout.createSequentialGroup()
                        .addGap(500, 500, 500)
                        .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
                            .addComponent(btnSearch, javax.swing.GroupLayout.PREFERRED_SIZE, 290, javax.swing.GroupLayout.PREFERRED_SIZE)
                            .addComponent(txtSearch, javax.swing.GroupLayout.PREFERRED_SIZE, 290, javax.swing.GroupLayout.PREFERRED_SIZE)
                            .addComponent(btnParseNewData, javax.swing.GroupLayout.PREFERRED_SIZE, 290, javax.swing.GroupLayout.PREFERRED_SIZE))))
                .addContainerGap(145, Short.MAX_VALUE))
        );
        layout.setVerticalGroup(
            layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGroup(layout.createSequentialGroup()
                .addGap(40, 40, 40)
                .addComponent(jLabel1)
                .addGap(21, 21, 21)
                .addComponent(lblWelcome)
                .addGap(17, 17, 17)
                .addComponent(txtSearch, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE)
                .addGap(18, 18, 18)
                .addComponent(btnSearch)
                .addGap(18, 18, 18)
                .addComponent(btnParseNewData)
                .addGap(53, 53, 53))
        );
    }// </editor-fold>//GEN-END:initComponents

    private void btnSearchActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_btnSearchActionPerformed
        // TODO add your handling code here:

        Porter porter = new Porter();

        String search = txtSearch.getText();

        String[] searchText = search.split(" ");
        ArrayList<String> words = new ArrayList<>();

        for (int i = 0; i < searchText.length; i++) {

            if (!stopList.contains(searchText[i])) {
                words.add(porter.stripAffixes(searchText[i]));
            }
        }

        int numberOfWords = words.size();

        String currentWord = null;
        String nextWord = null;

        Graph.Node node = null;
        Graph.Node previousNode = null;

        //will store the documentId's in which the complete match is found
        ArrayList<Integer> foundDocuments = new ArrayList<>();

        ArrayList<Integer> document = null;
        ArrayList<Graph.Node> nextNodes = null;
//-----------------------------------------------------------

        if (words.size() == 1) {
            String searchWord = porter.stripAffixes(words.get(0));
            if (indexTable.getIndexTable().containsKey(searchWord)) {
                node = indexTable.getIndexTable().get(searchWord);

                //gives all the documents in which the current node value is present
                foundDocuments = node.getDocumentIdList();
            }
        } else {
            String searchWord = porter.stripAffixes(words.get(0));
            if (indexTable.getIndexTable().containsKey(searchWord)) {

                //get the node of the current word
                node = indexTable.getIndexTable().get(searchWord);

                //gives all the documents in which the current node value is present
                document = node.getDocumentIdList();

                //get all the next pointing nodes
                nextNodes = node.getNextVertices();

                for (int docId : document) {

                    int i = 0;
                    currentWord = porter.stripAffixes(words.get(i));
                    i = i + 1;
                    nextWord = porter.stripAffixes(words.get(i));
                    
                    while(i < numberOfWords){
                        nextNodes = node.getNextVertices();
                    for (Node n : nextNodes) {
                        if (n.getValue().equalsIgnoreCase(nextWord)) {

                            if (n.getDocumentIdList().contains(docId)) {

                                i++;
                                if (i < numberOfWords) {
                                    currentWord = nextWord;
                                    nextWord = porter.stripAffixes(words.get(i));
                                    node = indexTable.getIndexTable().get(currentWord);
                                    
                                } else {
                                    if (!foundDocuments.contains(docId)) {
                                        foundDocuments.add(docId);
                                    }
                                }
                            }
                        }
                    }//for----
                    }
                }

            }

//            RankingFunction rf = new RankingFunction();
//            Integer totalDocumentCount = docCatalog.getTotalDocuments();
//            Double averageDocumentLength = ((docCatalog.getTotalWordCount() * 1.0) / totalDocumentCount);
//
//            Integer termFreqInQuery = 0;
//            Integer wordCountInDocument;
//            Integer noOfDocumentsContainingWord;
//            Integer totalWordsInDocument;
//            int documentId;
//            Double score;
//            Double temp;
//            
//            //Set<Double> finalScore = new HashSet<>();
//            HashMap<Integer, Double> ranking = new HashMap();
//            for (int i = 0; i < words.size(); i++) {
//                String value = words.get(i);
//
//                for (int j = 0; j < words.size(); j++) {
//                    if (value.equalsIgnoreCase(words.get(j))) {
//                        termFreqInQuery++;
//                    }
//                }
//
//                noOfDocumentsContainingWord = newIndex.table.get(value).size();
//
//                for (int k = 0; k < noOfDocumentsContainingWord; k++) {
//                    docSet = newIndex.table.get(value).keySet();
//                    
//                    for (int p = 0; p < docSet.size(); p++) {
//
//                        for (int docuId : docSet) {
//                            wordCountInDocument = newIndex.table.get(value).get(docuId);
//
//                            for (Doc d : docList) {
//
//                                if (docuId == d.getId()) {
//                                    totalWordsInDocument = d.getDocumentWordCount();
//
//                                    score = rf.getRank(totalDocumentCount, termFreqInQuery, wordCountInDocument, noOfDocumentsContainingWord, totalWordsInDocument, averageDocumentLength);
//
//                                    if (ranking.containsKey(docuId)) {
//                                        temp = ranking.get(docuId);
//                                        temp = temp + score;
//                                        ranking.put(docuId, temp);
//                                    } else {
//                                        ranking.put(docuId, score);
//                                    }
//                                }
//                            }
//                        }
//                    }
//                }
//
//            }
//            
//            ArrayList<Double> finalScore = new ArrayList<>();
//            
//            for(int docuId : docSet){
//                finalScore.add(ranking.get(docuId));
//            }
//            System.out.println("Before Sort");
//            
//            for(double d : finalScore){
//                System.out.println(d);
//            }
//            Collections.sort(finalScore);
//
//            System.out.println("After sort");
//            for(double d : finalScore){
//                System.out.println(d);
//            }
//            
//            for(int i = 0; i < finalScore.size(); i++){
//                
//                for(int docuId : docSet){
//                    
//                    if(ranking.get(docuId) == finalScore.get(i) && !foundDocuments.contains(docuId)){
//                        foundDocuments.add(docuId);
//                        break;
//                    }
//                }
//                
//            }
        }

        SearchResultJDialog srjd = new SearchResultJDialog(mainJFrame, true, foundDocuments, documentList);
        srjd.setVisible(true);
        srjd.setLocationRelativeTo(null);
        srjd.setTitle("Search Result");
        srjd.setDefaultCloseOperation(ParseJDialog.DISPOSE_ON_CLOSE);
        //-----------------------------------------------------------------
        System.out.println("Done");

    }//GEN-LAST:event_btnSearchActionPerformed

    private void btnParseNewDataActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_btnParseNewDataActionPerformed
        // TODO add your handling code here:
        ParseJDialog pjd = new ParseJDialog(mainJFrame, true, selectedFiles, documentList, indexTable, docList, newIndex, stopList, docCatalog);
        pjd.setVisible(true);
        pjd.setLocationRelativeTo(null);
        pjd.setTitle("Parse Data");
        pjd.setDefaultCloseOperation(ParseJDialog.DISPOSE_ON_CLOSE);
    }//GEN-LAST:event_btnParseNewDataActionPerformed


    // Variables declaration - do not modify//GEN-BEGIN:variables
    private javax.swing.JButton btnParseNewData;
    private javax.swing.JButton btnSearch;
    private javax.swing.JLabel jLabel1;
    private javax.swing.JLabel lblWelcome;
    private javax.swing.JTextField txtSearch;
    // End of variables declaration//GEN-END:variables
}
